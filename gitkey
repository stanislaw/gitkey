#! /usr/bin/env python

import importlib.util
import os
import sys
import subprocess
import termios
import tty
from datetime import datetime
from pathlib import Path
from sys import platform
from typing import Callable, Optional


VERSION = "0.1.0"


def paste_from_clipboard() -> str:
    if platform == "darwin":
        pbpaste = subprocess.Popen(["pbpaste"], stdout=subprocess.PIPE)
        stdout, _ = pbpaste.communicate()
        return stdout.decode("utf-8").strip()
    elif platform == "linux":
        xclip = subprocess.Popen(
            ["xclip", "-selection", "clipboard", "-o"], stdout=subprocess.PIPE
        )
        stdout, _ = xclip.communicate()
        return stdout.decode("utf-8").strip()
    else:
        raise RuntimeError(f"Unsupported platform: {platform}")


class RFXCustomFormatter:
    inverted = "\x1b[7;90m"
    reset = "\x1b[0m"

    @staticmethod
    def print(message: str, color: str) -> None:
        print(RFXCustomFormatter.format(message, color))

    @staticmethod
    def format(message: str, color: str) -> str:
        return color + message + RFXCustomFormatter.reset


class GitClient:
    def add_all(self) -> None:
        command = "git add --all"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def branch_latest(self, all: bool = False) -> None:
        args = [
            "git",
            "for-each-ref",
            "--sort=committerdate",
            "--format=%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))",
        ]

        args.append("refs/heads/")
        if all:
            args.append("refs/remotes/")

        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def commit(
        self,
        amend: bool = False,
        no_edit: bool = False,
        message: Optional[str] = None,
    ) -> None:
        args = ["git", "commit"]
        if amend:
            args.append("--amend")
        if no_edit:
            args.append("--no-edit")
        if message is not None:
            args.append("-m")
            args.append(message)
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def check_if_git_branch(self, text: str) -> bool:
        args = ["git", "rev-parse", "--verify", text]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        try:
            subprocess.run(args, capture_output=False, check=True, text=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def checkout_existing_branch(self, branch_name: str) -> None:
        assert isinstance(branch_name, str)
        args = ["git", "checkout", branch_name]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, check=True, text=True)

    def checkout_new_branch(self, branch_name: str) -> None:
        assert isinstance(branch_name, str)
        args = ["git", "switch", "-c", branch_name]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, check=True, text=True)

    def checkout_branch_using_fzf(self) -> None:
        # Get the list of branches, sorted by committer date
        branches = subprocess.run(
            [
                "git",
                "for-each-ref",
                "--sort=-committerdate",
                "--format=%(refname:short)",
                "refs/heads/",
                "refs/remotes/",
            ],
            capture_output=True,
            text=True,
            check=True,
        ).stdout.splitlines()

        # Open fzf with terminal interaction
        fzf = subprocess.Popen(
            ["fzf", "--ansi", "--prompt=Select branch> "],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
        )
        selected_branch, _ = fzf.communicate(input="\n".join(branches))
        selected_branch = selected_branch.strip()

        if selected_branch:
            if selected_branch.startswith("origin/"):
                selected_branch = selected_branch.removeprefix("origin/")

            # Switch to the selected branch
            subprocess.run(["git", "switch", selected_branch], check=True)
        else:
            print("No branch selected.")

    def diff(self, target: Optional[str] = None) -> None:
        args = ["git", "diff"]
        if target is not None:
            args.append(target)
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def fetch(self) -> None:
        command = "git fetch"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def log(self, commits: Optional[int] = None) -> None:
        args = ["git", "log"]
        if commits is not None:
            assert isinstance(commits, int), commits
            args.append(f"-l{commits}")
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def push(self, force: bool = False) -> None:
        args = ["git", "push"]
        if force:
            args.append("--force")
        command_color = RFXCustomFormatter.inverted
        command = " ".join(args)
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def pull(self) -> None:
        args = ["git", "pull"]
        command_color = RFXCustomFormatter.inverted
        command = " ".join(args)
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def pull_rebase(self) -> None:
        args = ["git", "pull", "--rebase"]
        command_color = RFXCustomFormatter.inverted
        command = " ".join(args)
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def rebase(self, branch: str) -> None:
        assert isinstance(branch, str)
        command = f"git rebase {branch}"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def rebase_abort(self) -> None:
        command = "git rebase --abort"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def rebase_continue(self) -> None:
        command = "git rebase --continue"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def rebase_interactive(self) -> None:
        command = "git rebase origin/main -i"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def show(self) -> None:
        command = "git show"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def status(self) -> None:
        status_command = "git status"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(status_command, command_color)
        subprocess.run(
            status_command.split(" "), capture_output=False, text=True
        )

    def switch_to_main(self) -> None:
        switch_command = "git switch main"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(switch_command, command_color)
        subprocess.run(
            switch_command.split(" "), capture_output=False, text=True
        )

    def switch_to_previous_branch(self) -> None:
        switch_command = "git switch -"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(switch_command, command_color)
        subprocess.run(
            switch_command.split(" "), capture_output=False, text=True
        )

    def reset_soft_unstage(self, target: Optional[str] = None) -> None:
        args = ["git", "reset"]
        if target is not None:
            args.append(target)
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def reset_hard(self, revision: str = "") -> None:
        # First, preserve the diff.
        print("")
        self._apply_patch()
        print("")

        revision_argument = revision if len(revision) > 0 else ""
        reset_command = f"git reset --hard {revision_argument}".rstrip()
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(reset_command, command_color)
        subprocess.run(
            reset_command.split(" "), capture_output=False, text=True
        )

    def clean_all(self) -> None:
        clean_command = "git clean -d --force"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(clean_command, command_color)
        subprocess.run(
            clean_command.split(" "), capture_output=False, text=True
        )

    def _apply_patch(self) -> None:
        result = subprocess.run(
            "git diff HEAD".split(" "), capture_output=True, text=True
        )
        assert result.returncode == 0
        if len(result.stdout) == 0:
            print(
                "**********************************************************************"
            )
            print("The diff is empty. Not creating a patch.")
            print(
                "**********************************************************************"
            )
            return

        path_to_user_dir = Path.home()
        patches_dir = path_to_user_dir.joinpath("patches")
        patches_dir.mkdir(parents=True, exist_ok=True)

        now = datetime.now()
        formatted_date = now.strftime("%Y%m%d_%H%M%S_%f")
        path_to_out_patch = patches_dir.joinpath(f"{formatted_date}.patch")

        with open(path_to_out_patch, "w") as out_patch:
            out_patch.write(result.stdout)
        print(
            "**********************************************************************"
        )
        print(f"Created a patch: {path_to_out_patch}")
        print(
            "**********************************************************************"
        )

    def is_top_merge_commit(self) -> bool:
        is_merge = (
            len(
                subprocess.check_output(
                    ["git", "show", "-s", "--pretty=%P"]
                ).split()
            )
            > 1
        )
        return is_merge


def get_key() -> str:
    if os.environ.get("GITKEY_TEST_INPUT") == "1" or not sys.stdin.isatty():
        return sys.stdin.read(1)

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch


def load_user_bindings(
    default_bindings: dict[str, Callable[["GitClient"], None]],
) -> dict[str, Callable[["GitClient"], None]]:
    config_path = os.environ.get("GITKEY_CONFIG")
    search_paths: list[str] = []
    if config_path:
        search_paths.append(config_path)
    else:
        search_paths.append(os.path.join(Path.home(), ".gitkey", "config.py"))

    for path in search_paths:
        if not os.path.isfile(path):
            continue

        spec = importlib.util.spec_from_file_location(
            "gitkey_user_config", path
        )
        if spec is None or spec.loader is None:
            print(f"error: failed to load config from {path}", file=sys.stderr)
            return default_bindings

        module = importlib.util.module_from_spec(spec)
        try:
            spec.loader.exec_module(module)
        except Exception as exc:
            print(
                f"error: failed to execute config {path}: {exc}",
                file=sys.stderr,
            )
            return default_bindings

        user_bindings = getattr(module, "BINDINGS", None)
        if user_bindings is None:
            return default_bindings
        if not isinstance(user_bindings, dict):
            print(
                f"error: BINDINGS in {path} must be a dict",
                file=sys.stderr,
            )
            return default_bindings

        merged = default_bindings.copy()
        merged.update(user_bindings)
        return merged

    return default_bindings


def main() -> None:
    git_client = GitClient()

    debug = False
    current_pattern = ""

    def new_branch() -> None:
        try:
            input_branch = input("Enter new branch name to checkout: ").strip()
        except KeyboardInterrupt:
            sys.exit(0)

        if len(input_branch) == 0:
            print("error: branch name cannot be empty.")
            sys.exit(1)

        if "/" not in input_branch:
            username = os.environ.get("USER", None)
            if username is not None:
                username = username.lower()
                input_branch = f"{username}/{input_branch}"

        git_client.checkout_new_branch(input_branch)

    def checkout_from_clipboard() -> None:
        copied_text = paste_from_clipboard()
        if git_client.check_if_git_branch(copied_text) or (
            "origin/" not in copied_text
            and git_client.check_if_git_branch(f"origin/{copied_text}")
        ):
            git_client.checkout_existing_branch(copied_text)
            return

        print("error: not a valid git branch.")
        sys.exit(1)

    def hard_reset_flow() -> None:
        git_client.status()
        response = input("Continue? [y/n]: ").strip().lower()
        if response not in ["y", "yes"]:
            print("Please enter 'y' or 'n'.")
            sys.exit(1)

        git_client.reset_hard()
        git_client.clean_all()
        git_client.status()

    def amend_if_possible() -> None:
        if git_client.is_top_merge_commit():
            print("error: cannot perform + on a merge commit.")
            sys.exit(1)
        git_client.add_all()
        git_client.status()
        git_client.commit(amend=True, no_edit=True)
        git_client.status()

    default_bindings: dict[str, Callable[[GitClient], None]] = {
        "\t": lambda gc: (
            gc.fetch(),
            gc.rebase("origin/main"),
            gc.status(),
        ),
        "27[A": lambda gc: (gc.push(), gc.status()),
        "27[1;2A": lambda gc: (gc.push(force=True), gc.status()),
        "27[B": lambda gc: (gc.pull(), gc.status()),
        "27[1;2B": lambda gc: (gc.pull_rebase(), gc.status()),
        "27[D": lambda gc: (gc.switch_to_previous_branch(), gc.status()),
        "27[1;2D": lambda gc: (gc.rebase_abort(), gc.status()),
        "27[C": lambda gc: (gc.checkout_branch_using_fzf(), gc.status()),
        "27[1;2C": lambda gc: (gc.rebase_continue(), gc.status()),
        "27[Z": lambda gc: (
            gc.fetch(),
            gc.rebase_interactive(),
            gc.status(),
        ),
        "A": lambda gc: (gc.add_all(), gc.status()),
        "B": lambda gc: gc.branch_latest(all=True),
        "C": lambda gc: (gc.commit(), gc.status()),
        "D": lambda gc: gc.diff(),
        "F": lambda gc: (gc.fetch(), gc.status()),
        "H": lambda gc: gc.show(),
        "L": lambda gc: gc.log(),
        "N": lambda _gc: new_branch(),
        "O": lambda _gc: checkout_from_clipboard(),
        "S": lambda gc: gc.status(),
        "M": lambda gc: (gc.switch_to_main(), gc.pull(), gc.status()),
        "W": lambda gc: (gc.commit(message="WIP"), gc.status()),
        "!": lambda _gc: hard_reset_flow(),
        "8": lambda gc: (gc.reset_hard("HEAD^"), gc.status()),
        "9": lambda gc: (gc.reset_soft_unstage("HEAD^"), gc.status()),
        "0": lambda gc: (gc.reset_soft_unstage(), gc.status()),
        "+": lambda _gc: amend_if_possible(),
        "bl1": lambda gc: gc.branch_latest(),
        "bl2": lambda gc: gc.branch_latest(all=True),
        "cm2": lambda gc: (gc.commit(amend=True), gc.status()),
        "cm3": lambda gc: (gc.commit(amend=True, no_edit=True), gc.status()),
        "di1": lambda gc: gc.diff(),
        "di2": lambda gc: gc.diff(target="HEAD"),
    }

    bindings = load_user_bindings(default_bindings)

    def has_prefix(pattern: str) -> bool:
        return any(key.startswith(pattern) for key in bindings.keys())

    escape = False

    while True:
        c = get_key()
        if c == "":
            sys.exit(0)

        if ord(c) == 3:
            print("")
            sys.exit(0)

        # Escape sequence
        if ord(c) == 27:
            escape = True
            current_pattern = "27"
            continue

        # Backspace
        if ord(c) == 127:
            current_pattern = current_pattern[:-2]
            print(f"Correcting pattern: {current_pattern}")
            continue

        current_pattern += c

        if debug:
            print(c, ord(c), end=None)
            print(f"PATT: '{current_pattern}'")

        binding = bindings.get(current_pattern)
        if binding is not None:
            binding(git_client)
            sys.exit(0)

        if escape and not has_prefix(current_pattern):
            escape = False
            current_pattern = ""
        elif not escape and not has_prefix(current_pattern):
            current_pattern = ""


if __name__ == "__main__":
    main()
