#! /usr/bin/env python

import importlib.util
import os
import sys
import subprocess
import termios
import tty
from datetime import datetime
from pathlib import Path
from sys import platform
from typing import Callable, Optional


VERSION = "0.1.0"


def paste_from_clipboard() -> str:
    if platform == "darwin":
        pbpaste = subprocess.Popen(["pbpaste"], stdout=subprocess.PIPE)
        stdout, _ = pbpaste.communicate()
        return stdout.decode("utf-8").strip()
    elif platform == "linux":
        xclip = subprocess.Popen(
            ["xclip", "-selection", "clipboard", "-o"], stdout=subprocess.PIPE
        )
        stdout, _ = xclip.communicate()
        return stdout.decode("utf-8").strip()
    else:
        raise RuntimeError(f"Unsupported platform: {platform}")


class RFXCustomFormatter:
    inverted = "\x1b[7;90m"
    reset = "\x1b[0m"

    @staticmethod
    def print(message: str, color: str) -> None:
        print(RFXCustomFormatter.format(message, color))

    @staticmethod
    def format(message: str, color: str) -> str:
        return color + message + RFXCustomFormatter.reset


class GitClient:
    def add(self, include_untracked: bool = True, patch: bool = False) -> None:
        patch_string = "--patch" if patch else ""
        include_untracked_string = "--update" if not include_untracked else ""

        command: str = (
            f"git add . {patch_string} {include_untracked_string}".replace(
                "  ", " "
            ).strip()
        )

        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def add_add_untracked_without_staging(self) -> None:
        command = "git add --intent-to-add ."
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def add_patch_include_untracked(self) -> None:
        for command in ("git add --intent-to-add .", "git add --patch"):
            command_color = RFXCustomFormatter.inverted
            RFXCustomFormatter.print(command, command_color)
            subprocess.run(command.split(" "), capture_output=False, text=True)

    def branch_latest(self, all: bool = False) -> None:
        args = [
            "git",
            "for-each-ref",
            "--sort=committerdate",
            "--format=%(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname) (%(color:green)%(committerdate:relative)%(color:reset))",
        ]

        args.append("refs/heads/")
        if all:
            args.append("refs/remotes/")

        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def commit(
        self,
        amend: bool = False,
        no_edit: bool = False,
        message: Optional[str] = None,
    ) -> None:
        args = ["git", "commit"]
        if amend:
            args.append("--amend")
        if no_edit:
            args.append("--no-edit")
        if message is not None:
            args.append("-m")
            args.append(message)
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def check_if_git_branch(self, text: str) -> bool:
        args = ["git", "rev-parse", "--verify", text]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        try:
            subprocess.run(args, capture_output=False, check=True, text=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def checkout_existing_branch(self, branch_name: str) -> None:
        assert isinstance(branch_name, str)
        args = ["git", "checkout", branch_name]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, check=True, text=True)

    def checkout_new_branch(self, branch_name: str) -> None:
        assert isinstance(branch_name, str)
        args = ["git", "switch", "-c", branch_name]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, check=True, text=True)

    def checkout_branch_using_fzf(self) -> None:
        # Get the list of branches, sorted by committer date
        branches = subprocess.run(
            [
                "git",
                "for-each-ref",
                "--sort=-committerdate",
                "--format=%(refname:short)",
                "refs/heads/",
                "refs/remotes/",
            ],
            capture_output=True,
            text=True,
            check=True,
        ).stdout.splitlines()

        # Open fzf with terminal interaction
        fzf = subprocess.Popen(
            ["fzf", "--ansi", "--prompt=Select branch> "],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
        )
        selected_branch, _ = fzf.communicate(input="\n".join(branches))
        selected_branch = selected_branch.strip()

        if selected_branch:
            if selected_branch.startswith("origin/"):
                selected_branch = selected_branch.removeprefix("origin/")

            # Switch to the selected branch
            subprocess.run(["git", "switch", selected_branch], check=True)
        else:
            print("No branch selected.")

    def diff(self, target: Optional[str] = None) -> None:
        args = ["git", "diff"]
        if target is not None:
            args.append(target)
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def fetch(self) -> None:
        command = "git fetch"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def log(self, commits: Optional[int] = None) -> None:
        args = ["git", "log"]
        if commits is not None:
            assert isinstance(commits, int), commits
            args.append(f"-l{commits}")
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def push(self, force: bool = False) -> None:
        args = ["git", "push"]
        if force:
            args.append("--force")
        command_color = RFXCustomFormatter.inverted
        command = " ".join(args)
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def pull(self) -> None:
        args = ["git", "pull"]
        command_color = RFXCustomFormatter.inverted
        command = " ".join(args)
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True, check=True)

    def pull_rebase(self) -> None:
        args = ["git", "pull", "--rebase"]
        command_color = RFXCustomFormatter.inverted
        command = " ".join(args)
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def rebase(self, branch: str) -> None:
        assert isinstance(branch, str)
        command = f"git rebase {branch}"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def rebase_abort(self) -> None:
        command = "git rebase --abort"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def rebase_continue(self) -> None:
        command = "git rebase --continue"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def rebase_interactive(self) -> None:
        command = "git rebase origin/main -i"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def show(self) -> None:
        command = "git show"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def status(self) -> None:
        status_command = "git status"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(status_command, command_color)
        subprocess.run(
            status_command.split(" "), capture_output=False, text=True
        )

    def stash(self, include_untracked: bool = False) -> None:
        args = ["git", "stash"]
        if include_untracked:
            args.append("--include-untracked")
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def stash_pop(self) -> None:
        command = "git stash pop"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(command.split(" "), capture_output=False, text=True)

    def stash_show(self, include_untracked: bool = False) -> None:
        args = ["git", "stash", "show"]
        if include_untracked:
            args.append("--include-untracked")
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def top_commit_files(self) -> list[str]:
        args = [
            "git",
            "diff-tree",
            "--no-commit-id",
            "--name-only",
            "-r",
            "--diff-filter=AM",
            "HEAD",
        ]
        result = subprocess.run(
            args, capture_output=True, text=True, check=True
        )
        files = [line for line in result.stdout.splitlines() if line]
        return sorted(files)

    def remove_cached_file(self, path: str) -> None:
        args = ["git", "rm", "--cached", "--", path]
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True, check=True)

    def switch_to_main(self) -> None:
        switch_command = "git switch main"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(switch_command, command_color)
        subprocess.run(
            switch_command.split(" "), capture_output=False, text=True
        )

    def switch_to_previous_branch(self) -> None:
        switch_command = "git switch -"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(switch_command, command_color)
        subprocess.run(
            switch_command.split(" "), capture_output=False, text=True
        )

    def reset_soft_unstage(self, target: Optional[str] = None) -> None:
        args = ["git", "reset"]
        if target is not None:
            args.append(target)
        command = " ".join(args)
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(command, command_color)
        subprocess.run(args, capture_output=False, text=True)

    def reset_hard(self, revision: str = "HEAD") -> None:
        # First, preserve the diff.
        print("")
        self._apply_patch(revision)
        print("")

        revision_argument = revision if len(revision) > 0 else ""
        reset_command = f"git reset --hard {revision_argument}".rstrip()
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(reset_command, command_color)
        subprocess.run(
            reset_command.split(" "), capture_output=False, text=True
        )

    def clean_all(self) -> None:
        clean_command = "git clean -d --force"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(clean_command, command_color)
        subprocess.run(
            clean_command.split(" "), capture_output=False, text=True
        )

    def _apply_patch(self, revision: str) -> None:
        # This is needed to include untracked files in the diff.
        self.add_add_untracked_without_staging()

        diff_command = f"git diff {revision}"
        command_color = RFXCustomFormatter.inverted
        RFXCustomFormatter.print(diff_command, command_color)
        result = subprocess.run(
            f"git diff {revision}".split(" "), capture_output=True, text=True
        )
        assert result.returncode == 0
        if len(result.stdout) == 0:
            print(
                "**********************************************************************"
            )
            print("The diff is empty. Not creating a patch.")
            print(
                "**********************************************************************"
            )
            self.reset_soft_unstage()
            return

        patches_dir = Path.home() / ".gitkey" / "patches"
        patches_dir.mkdir(parents=True, exist_ok=True)

        now = datetime.now()
        formatted_date = now.strftime("%Y%m%d_%H%M%S_%f")
        path_to_out_patch = patches_dir.joinpath(f"{formatted_date}.patch")

        with open(path_to_out_patch, "w") as out_patch:
            out_patch.write(result.stdout)
        print("*" * len(path_to_out_patch.as_posix()))
        print("Creating a patch:")
        print(path_to_out_patch.as_posix())
        print("*" * len(path_to_out_patch.as_posix()))

        # This reverts the staging of untracked files. This also reverts any
        # changes to tracked files that were staged, but that is ok since this
        # patch preservation is anyway a very special operation.
        self.reset_soft_unstage()

    def is_top_merge_commit(self) -> bool:
        is_merge = (
            len(
                subprocess.check_output(
                    ["git", "show", "-s", "--pretty=%P"]
                ).split()
            )
            > 1
        )
        return is_merge


def get_key() -> str:
    if os.environ.get("GITKEY_TEST_INPUT") == "1" or not sys.stdin.isatty():
        return sys.stdin.read(1)

    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
    return ch


def load_user_bindings(
    default_bindings: dict[str, Callable[["GitClient"], None]],
) -> dict[str, Callable[["GitClient"], None]]:
    config_path = os.environ.get("GITKEY_CONFIG")
    search_paths: list[str] = []
    if config_path:
        search_paths.append(config_path)
    else:
        search_paths.append(os.path.join(Path.home(), ".gitkey", "config.py"))

    for path in search_paths:
        if not os.path.isfile(path):
            continue

        spec = importlib.util.spec_from_file_location(
            "gitkey_user_config", path
        )
        if spec is None or spec.loader is None:
            print(f"error: failed to load config from {path}", file=sys.stderr)
            return default_bindings

        module = importlib.util.module_from_spec(spec)
        try:
            spec.loader.exec_module(module)
        except Exception as exc:
            print(
                f"error: failed to execute config {path}: {exc}",
                file=sys.stderr,
            )
            return default_bindings

        user_bindings = getattr(module, "BINDINGS", None)
        if user_bindings is None:
            return default_bindings
        if not isinstance(user_bindings, dict):
            print(
                f"error: BINDINGS in {path} must be a dict",
                file=sys.stderr,
            )
            return default_bindings

        merged = default_bindings.copy()
        merged.update(user_bindings)
        return merged

    return default_bindings


def main() -> None:
    git_client = GitClient()

    debug = False
    current_pattern = ""

    def new_branch() -> None:
        try:
            input_branch = input("Enter new branch name to checkout: ").strip()
        except KeyboardInterrupt:
            sys.exit(0)

        if len(input_branch) == 0:
            print("error: branch name cannot be empty.")
            sys.exit(1)

        if "/" not in input_branch:
            username = os.environ.get("USER", None)
            if username is not None:
                username = username.lower()
                input_branch = f"{username}/{input_branch}"

        git_client.checkout_new_branch(input_branch)

    def checkout_from_clipboard() -> None:
        copied_text = paste_from_clipboard()
        if git_client.check_if_git_branch(copied_text) or (
            "origin/" not in copied_text
            and git_client.check_if_git_branch(f"origin/{copied_text}")
        ):
            git_client.checkout_existing_branch(copied_text)
            return

        print("error: not a valid git branch.")
        sys.exit(1)

    def hard_reset_flow() -> None:
        git_client.status()
        response = input("Continue? [y/n]: ").strip().lower()
        if response not in ["y", "yes"]:
            print("Please enter 'y' or 'n'.")
            sys.exit(1)

        git_client.reset_hard()
        git_client.clean_all()
        git_client.status()

    def hard_reset_to_previous_commit_flow() -> None:
        git_client.status()
        response = input("Continue? [y/n]: ").strip().lower()
        if response not in ["y", "yes"]:
            print("Please enter 'y' or 'n'.")
            sys.exit(1)

        git_client.reset_hard("HEAD^")
        git_client.status()

    def soft_reset_to_previous_commit_flow() -> None:
        git_client.status()
        response = input("Continue? [y/n]: ").strip().lower()
        if response not in ["y", "yes"]:
            print("Please enter 'y' or 'n'.")
            sys.exit(1)

        git_client.reset_soft_unstage("HEAD^")
        git_client.status()

    def amend_if_possible(*, include_untracked: bool) -> None:
        if git_client.is_top_merge_commit():
            symbol = "=" if not include_untracked else "+"
            print(f"error: cannot perform {symbol} on a merge commit.")
            sys.exit(1)
        git_client.add(include_untracked=include_untracked)
        git_client.status()
        git_client.commit(amend=True, no_edit=True)
        git_client.status()

    def run_chain(gc: GitClient, *steps: Callable[[GitClient], None]) -> None:
        for step in steps:
            step(gc)

    def remove_from_top_commit() -> None:
        if git_client.is_top_merge_commit():
            print("error: cannot amend a merge commit.")
            sys.exit(1)

        files = git_client.top_commit_files()
        if len(files) == 0:
            print("No modified or added files found in the top commit.")
            sys.exit(0)

        fzf = subprocess.Popen(
            ["fzf", "--ansi", "--prompt=Remove from top commit> "],
            stdin=subprocess.PIPE,
            stdout=subprocess.PIPE,
            text=True,
        )
        selected_file, _ = fzf.communicate(input="\n".join(files))
        selected_file = selected_file.strip()

        if selected_file:
            git_client.remove_cached_file(selected_file)
            git_client.commit(amend=True, no_edit=True)
        else:
            print("No file selected.")
            sys.exit(0)

    default_bindings: dict[str, Callable[[GitClient], None]] = {
        "\t": lambda gc: run_chain(
            gc,
            lambda g: g.fetch(),
            lambda g: g.rebase("origin/main"),
            lambda g: g.status(),
        ),
        "27[A": lambda gc: run_chain(
            gc, lambda g: g.push(), lambda g: g.status()
        ),
        "27[1;2A": lambda gc: run_chain(
            gc, lambda g: g.push(force=True), lambda g: g.status()
        ),
        "27[B": lambda gc: run_chain(
            gc, lambda g: g.pull(), lambda g: g.status()
        ),
        "27[1;2B": lambda gc: run_chain(
            gc, lambda g: g.pull_rebase(), lambda g: g.status()
        ),
        "27[D": lambda gc: run_chain(
            gc, lambda g: g.switch_to_previous_branch(), lambda g: g.status()
        ),
        "27[1;2D": lambda gc: run_chain(
            gc, lambda g: g.rebase_abort(), lambda g: g.status()
        ),
        "27[C": lambda gc: run_chain(
            gc, lambda g: g.checkout_branch_using_fzf(), lambda g: g.status()
        ),
        "27[1;2C": lambda gc: run_chain(
            gc, lambda g: g.rebase_continue(), lambda g: g.status()
        ),
        "27[Z": lambda gc: run_chain(
            gc,
            lambda g: g.fetch(),
            lambda g: g.rebase_interactive(),
            lambda g: g.status(),
        ),
        "A": lambda gc: run_chain(
            gc, lambda g: g.add(include_untracked=True), lambda g: g.status()
        ),
        "B": lambda gc: gc.branch_latest(all=True),
        "C": lambda gc: run_chain(
            gc, lambda g: g.commit(), lambda g: g.status()
        ),
        "D": lambda gc: gc.diff(),
        "F": lambda gc: run_chain(
            gc, lambda g: g.fetch(), lambda g: g.status()
        ),
        "H": lambda gc: gc.show(),
        "L": lambda gc: gc.log(),
        "N": lambda _gc: new_branch(),
        "O": lambda _gc: checkout_from_clipboard(),
        "S": lambda gc: gc.status(),
        "M": lambda gc: run_chain(
            gc,
            lambda g: g.switch_to_main(),
            lambda g: g.pull(),
            lambda g: g.status(),
        ),
        "W": lambda gc: run_chain(
            gc, lambda g: g.commit(message="WIP"), lambda g: g.status()
        ),
        "!": lambda _gc: hard_reset_flow(),
        "8": lambda _gc: hard_reset_to_previous_commit_flow(),
        "9": lambda _gc: soft_reset_to_previous_commit_flow(),
        "0": lambda gc: run_chain(
            gc, lambda g: g.reset_soft_unstage(), lambda g: g.status()
        ),
        "+": lambda _gc: amend_if_possible(include_untracked=True),
        "=": lambda _gc: amend_if_possible(include_untracked=False),
        "aa": lambda gc: gc.add(include_untracked=False),
        "ap": lambda gc: gc.add(include_untracked=False, patch=True),
        "aP": lambda gc: gc.add_patch_include_untracked(),
        "bl1": lambda gc: gc.branch_latest(),
        "bl2": lambda gc: gc.branch_latest(all=True),
        "cm2": lambda gc: run_chain(
            gc, lambda g: g.commit(amend=True), lambda g: g.status()
        ),
        "cm3": lambda gc: run_chain(
            gc,
            lambda g: g.commit(amend=True, no_edit=True),
            lambda g: g.status(),
        ),
        "di1": lambda gc: gc.diff(),
        "di2": lambda gc: gc.diff(target="HEAD"),
        "[": lambda gc: gc.stash(),
        "{": lambda gc: gc.stash(include_untracked=True),
        "]": lambda gc: gc.stash_pop(),
        "}": lambda gc: gc.stash_show(include_untracked=True),
        "27[3~": lambda _gc: remove_from_top_commit(),
    }

    bindings = load_user_bindings(default_bindings)

    def has_prefix(pattern: str) -> bool:
        return any(key.startswith(pattern) for key in bindings.keys())

    escape = False

    while True:
        c = get_key()
        if c == "":
            sys.exit(0)

        if ord(c) == 3:
            print("")
            sys.exit(0)

        # Escape sequence
        if ord(c) == 27:
            escape = True
            current_pattern = "27"
            continue

        # Backspace
        if ord(c) == 127:
            current_pattern = current_pattern[:-2]
            print(f"Correcting pattern: {current_pattern}")
            continue

        current_pattern += c

        if debug:
            print(c, ord(c), end=None)
            print(f"PATT: '{current_pattern}'")

        binding = bindings.get(current_pattern)
        if binding is not None:
            binding(git_client)
            sys.exit(0)

        if escape and not has_prefix(current_pattern):
            escape = False
            current_pattern = ""
        elif not escape and not has_prefix(current_pattern):
            current_pattern = ""


if __name__ == "__main__":
    main()
